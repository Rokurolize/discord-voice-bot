"""Discord Voice TTS Bot - Type-safe Modular Implementation."""

import asyncio
from typing import TYPE_CHECKING, Any

import discord
from discord.ext import commands
from loguru import logger

from .command_handler import CommandHandler
from .config_manager import ConfigManagerImpl
from .event_handler import EventHandler
from .health_monitor import HealthMonitor
from .message_validator import MessageValidator
from .protocols import ConfigManager
from .status_manager import StatusManager
from .voice.handler import VoiceHandler
from .voice.stats_tracker import StatsTracker

if TYPE_CHECKING:
    from .slash.registry import SlashCommandRegistry as SlashCommandHandler


# DiscordVoiceBotTTS protocol is used for structural subtyping, no explicit import needed


class DiscordVoiceTTSBot(commands.Bot):
    """Truly minimal bot that delegates everything to modular handlers."""

    stats: "StatsTracker"
    config: ConfigManagerImpl | None
    config_manager: ConfigManager
    monitor_task: asyncio.Task[None] | None
    event_handler: EventHandler | None
    command_handler: CommandHandler | None
    slash_handler: "SlashCommandHandler | None"
    status_manager: StatusManager | None
    message_validator: MessageValidator | None
    voice_handler: "VoiceHandler | None"
    health_monitor: HealthMonitor | None
    startup_complete: bool

    def __init__(self, config: ConfigManagerImpl | None = None) -> None:
        """Initialize with modular components."""
        # Store config first to avoid issues with super().__init__
        self.config = config
        self.config_manager = ConfigManagerImpl()

        super().__init__(
            command_prefix=config.get_command_prefix() if config else "!",
            intents=config.get_intents() if config else discord.Intents.default(),
            help_command=None,
            case_insensitive=True,
        )

        # Initialize remaining attributes after super().__init__
        self.stats = StatsTracker()
        self.monitor_task = None
        self.startup_connection_failures = 0

        logger.debug("Discord.py v2.x initialization completed successfully")

        # Initialize attributes that need to be set before _init_components
        self.event_handler = None
        self.command_handler = None
        self.slash_handler = None
        self.status_manager = None
        self.message_validator = None
        self.voice_handler = None
        self.health_monitor = None
        self.startup_complete = False

        self._init_components()
        self._setup_handlers()

        logger.info("Discord Voice TTS Bot - Truly Minimal Modular")

    async def setup_hook(self) -> None:  # type: ignore[override]
        """Discord.py v2.x setup hook - called after login but before connecting to gateway."""
        logger.info("Running setup_hook for Discord.py v2.x compatibility")

        # Initialize slash commands after bot is logged in
        if self.slash_handler:
            try:
                await self.slash_handler.register_slash_commands()
                logger.info("Slash commands registered successfully via setup_hook")
            except Exception as e:
                logger.error(f"Failed to register slash commands in setup_hook: {e}")

        # Start any background tasks here if needed
        logger.debug("setup_hook completed successfully")

    def _init_components(self) -> None:
        """Initialize modular components."""
        # Initialize components that don't need the bot instance yet
        self.status_manager = StatusManager()
        self.message_validator = MessageValidator()

        # Initialize components that need the bot instance - defer to setup
        self.event_handler = None
        self.command_handler = None
        self.slash_handler = None
        self.voice_handler = None
        self.health_monitor = None
        self.startup_complete = False

    def _setup_handlers(self) -> None:
        """Setup event and command handlers."""
        # Initialize remaining components now that bot is fully initialized
        from .slash.registry import SlashCommandRegistry as SlashCommandHandler

        # Type ignore needed due to discord.py inheritance complexities
        self.event_handler = EventHandler(self, self.config_manager)
        self.command_handler = CommandHandler(self)
        self.slash_handler = SlashCommandHandler(self)
        self.voice_handler = VoiceHandler(self, self.config_manager)
        self.health_monitor = HealthMonitor(self, self.config_manager)

        self._setup_events()
        self._setup_commands()

    def _setup_events(self) -> None:
        """Setup Discord events - all delegated to event handler."""
        logger.debug("🔧 SETTING UP EVENTS: Starting event handler setup")

        # Event handlers are now initialized, so they should not be None
        if not self.event_handler:
            raise RuntimeError("Event handler not initialized")

        # Type assertion for mypy since we just checked it's not None
        event_handler = self.event_handler
        logger.debug("🔧 SETTING UP EVENTS: Event handler is available")

        @self.event
        async def on_ready() -> None:
            """Handle bot ready event - registered by Discord.py automatically."""
            logger.debug("🎉 EVENT: on_ready triggered")

            # Log detailed bot status
            logger.info(f"🤖 BOT STATUS: Logged in as {self.user}")
            logger.info(f"🤖 BOT STATUS: User ID: {self.user.id if self.user else 'None'}")
            logger.info(f"🤖 BOT STATUS: Connected to {len(self.guilds)} guilds")

            for guild in self.guilds:
                logger.info(f"🤖 BOT STATUS: Guild: {guild.name} (ID: {guild.id})")
                logger.info(f"🤖 BOT STATUS: Guild member count: {guild.member_count}")

                # Check if bot can see the target voice channel
                target_channel_id = self.config_manager.get_target_voice_channel_id()
                target_channel = guild.get_channel(target_channel_id)
                if target_channel:
                    logger.info(f"🤖 BOT STATUS: Found target voice channel: {target_channel.name}")
                    # Check bot permissions in the channel
                    if hasattr(target_channel, "permissions_for"):
                        bot_permissions = target_channel.permissions_for(guild.me)
                        logger.info("🤖 BOT STATUS: Bot permissions in voice channel:")
                        logger.info(f"  - Read Messages: {bot_permissions.read_messages}")
                        logger.info(f"  - Read Message History: {bot_permissions.read_message_history}")
                        logger.info(f"  - View Channel: {bot_permissions.view_channel}")
                        logger.info(f"  - Connect: {bot_permissions.connect}")
                        logger.info(f"  - Speak: {bot_permissions.speak}")
                        logger.info(f"  - Use Voice Activation: {bot_permissions.use_voice_activation}")
                else:
                    logger.warning(f"🤖 BOT STATUS: Target voice channel {target_channel_id} not found in guild {guild.name}")

            await event_handler.handle_ready()

        # Mark function as used by Discord.py event system
        _ = on_ready
        logger.debug("🔧 SETTING UP EVENTS: on_ready event registered")

        @self.event
        async def on_message(message: discord.Message) -> None:
            """Handle message events - registered by Discord.py automatically."""
            logger.debug(f"💬 EVENT: on_message triggered with message from {message.author.name}")
            logger.debug(f"💬 EVENT: Message content: '{message.content}' (length: {len(message.content)})")
            logger.debug(f"💬 EVENT: Message content (repr): {message.content!r}")
            logger.debug(f"💬 EVENT: Message content (hex): {message.content.encode('utf-8').hex() if message.content else 'None'}")
            logger.debug(f"💬 EVENT: Message type: {type(message)}, has content attr: {hasattr(message, 'content')}")
            logger.debug(f"💬 EVENT: Message channel: {message.channel} (ID: {message.channel.id})")
            logger.debug(f"💬 EVENT: Message author: {message.author} (ID: {message.author.id}, bot: {message.author.bot})")
            logger.debug(f"💬 EVENT: Message ID: {message.id}, timestamp: {message.created_at}")
            logger.debug(f"💬 EVENT: Message attachments: {len(message.attachments)}")
            logger.debug(f"💬 EVENT: Message embeds: {len(message.embeds)}")
            logger.debug(f"💬 EVENT: Message edited_timestamp: {message.edited_at}")
            logger.debug(f"💬 EVENT: Message reference: {message.reference}")
            try:
                logger.debug(f"💬 EVENT: Message raw data keys: {list(vars(message).keys())}")
            except TypeError:
                logger.debug("💬 EVENT: Cannot use vars() on message object - trying dir() instead")

            logger.debug(f"💬 EVENT: Message attributes: {[attr for attr in dir(message) if not attr.startswith('_')]}")

            # 🔍 DEEP DEBUGGING: Check all possible content sources
            logger.debug(f"🔍 DEEP DEBUG: message.content type: {type(message.content)}")
            logger.debug(f"🔍 DEEP DEBUG: message.content bool: {bool(message.content)}")
            logger.debug(f"🔍 DEEP DEBUG: hasattr clean_content: {hasattr(message, 'clean_content')}")
            if hasattr(message, 'clean_content'):
                logger.debug(f"🔍 DEEP DEBUG: clean_content: '{message.clean_content}' (len: {len(message.clean_content)})")
            logger.debug(f"🔍 DEEP DEBUG: hasattr system_content: {hasattr(message, 'system_content')}")
            if hasattr(message, 'system_content'):
                logger.debug(f"🔍 DEEP DEBUG: system_content: '{message.system_content}' (len: {len(message.system_content) if message.system_content else 0})")

            # Check raw message data
            try:
                import json
                raw_data = {k: v for k, v in vars(message).items() if not k.startswith('_') and not callable(v)}
                logger.debug(f"🔍 DEEP DEBUG: Raw message data keys: {list(raw_data.keys())}")
                for key, value in raw_data.items():
                    if key in ['content', 'clean_content', 'system_content', 'embeds', 'attachments']:
                        logger.debug(f"🔍 DEEP DEBUG: {key} = {repr(value)}")
            except Exception as raw_error:
                logger.debug(f"🔍 DEEP DEBUG: Error getting raw data: {raw_error}")

            # Check message type and flags
            logger.debug(f"🔍 DEEP DEBUG: Message type: {message.type}")
            logger.debug(f"🔍 DEEP DEBUG: Message flags: {message.flags}")
            logger.debug(f"🔍 DEEP DEBUG: Message is_system: {message.is_system}")
            logger.debug(f"🔍 DEEP DEBUG: Message tts: {message.tts}")


            # CRITICAL: Immediate content validation - Phase 1 Fix
            if not message.content or not message.content.strip():
                logger.error("🚨 CRITICAL: Empty message content detected - detailed analysis")
                logger.error(f"🚨 CRITICAL: Message ID: {message.id}")
                logger.error(f"🚨 CRITICAL: Author: {message.author.name} (ID: {message.author.id}, bot: {message.author.bot})")
                logger.error(f"🚨 CRITICAL: Channel: {message.channel.id}")
                logger.error(f"🚨 CRITICAL: Message type: {message.type}")
                logger.error(f"🚨 CRITICAL: Message timestamp: {message.created_at}")
                logger.error(f"🚨 CRITICAL: Message edited: {message.edited_at}")
                logger.error(f"🚨 CRITICAL: Message has reference: {message.reference is not None}")
                logger.error(f"🚨 CRITICAL: Message attachments: {len(message.attachments)}")
                logger.error(f"🚨 CRITICAL: Message embeds: {len(message.embeds)}")
                return

            # SUCCESS: Valid message content found - process directly
            logger.info(f"✅ SUCCESS: Valid message content: '{message.content}' (length: {len(message.content)})")

            # Phase 1: Direct TTS processing bypass - avoid complex event handler chain
            if message.channel.id == self.config_manager.get_target_voice_channel_id():
                logger.info("🔄 DIRECT TTS: Message is in target voice channel - attempting direct processing")

                if self.voice_handler:
                    try:
                        await self._process_tts_message_direct(message)
                        logger.info("✅ DIRECT TTS: Message processed successfully via direct path")
                        return  # Skip the complex event handler
                    except Exception as direct_error:
                        logger.error(f"❌ DIRECT TTS ERROR: Direct processing failed: {direct_error}")
                        logger.error("🔄 FALLBACK: Falling back to original event handler chain")
                        # Continue to original event handler as fallback
                else:
                    logger.warning("🔄 DIRECT TTS: No voice handler available - using fallback")

            # 特定のメッセージIDをチェック
            if message.id == 1408986318679179375:
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - ID: {message.id}")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Content: '{message.content}'")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Edited: {message.edited_at}")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Timestamp: {message.created_at}")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Author: {message.author}")
                logger.info("🔍 SPECIFIC MESSAGE CHECK - This is the message you mentioned!")
                if message.edited_at:
                    logger.warning("⚠️  MESSAGE WAS EDITED! The content might have been changed after sending.")
                else:
                    logger.info("✅ MESSAGE NOT EDITED - Original content received")

            # Check if message is in target channel
            target_channel_id = self.config_manager.get_target_voice_channel_id()
            logger.debug(f"💬 EVENT: Target channel ID: {target_channel_id}, current channel ID: {message.channel.id}")

            if message.channel.id == target_channel_id:
                logger.debug("💬 EVENT: Message is in target voice channel")
            else:
                logger.debug("💬 EVENT: Message is NOT in target voice channel")

            try:
                await event_handler.handle_message(message)
                logger.debug("💬 EVENT: handle_message completed successfully")
            except Exception as e:
                logger.error(f"💬 EVENT ERROR: handle_message failed: {e}")
                logger.error(f"💬 EVENT ERROR: Exception type: {type(e).__name__}")
                import traceback

                logger.error(f"💬 EVENT ERROR: Traceback: {traceback.format_exc()}")
</search>
</search_and_replace>
</search>
</search_and_replace>
                logger.error("🚨 CRITICAL: Empty message content detected - detailed analysis")
                logger.error(f"🚨 CRITICAL: Message ID: {message.id}")
                logger.error(f"🚨 CRITICAL: Author: {message.author.name} (ID: {message.author.id}, bot: {message.author.bot})")
                logger.error(f"🚨 CRITICAL: Channel: {message.channel.id}")
                logger.error(f"🚨 CRITICAL: Message type: {message.type}")
                logger.error(f"🚨 CRITICAL: Message timestamp: {message.created_at}")
                logger.error(f"🚨 CRITICAL: Message edited: {message.edited_at}")
                logger.error(f"🚨 CRITICAL: Message has reference: {message.reference is not None}")
                logger.error(f"🚨 CRITICAL: Message attachments: {len(message.attachments)}")
                logger.error(f"🚨 CRITICAL: Message embeds: {len(message.embeds)}")
                return

            # SUCCESS: Valid message content found - process directly
            logger.info(f"✅ SUCCESS: Valid message content: '{message.content}' (length: {len(message.content)})")

            # Phase 1: Direct TTS processing bypass - avoid complex event handler chain
            if message.channel.id == self.config_manager.get_target_voice_channel_id():
                logger.info("🔄 DIRECT TTS: Message is in target voice channel - attempting direct processing")

                if self.voice_handler:
                    try:
                        await self._process_tts_message_direct(message)
                        logger.info("✅ DIRECT TTS: Message processed successfully via direct path")
                        return  # Skip the complex event handler
                    except Exception as direct_error:
                        logger.error(f"❌ DIRECT TTS ERROR: Direct processing failed: {direct_error}")
                        logger.error("🔄 FALLBACK: Falling back to original event handler chain")
                        # Continue to original event handler as fallback
                else:
                    logger.warning("🔄 DIRECT TTS: No voice handler available - using fallback")

            # 特定のメッセージIDをチェック
            if message.id == 1408986318679179375:
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - ID: {message.id}")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Content: '{message.content}'")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Edited: {message.edited_at}")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Timestamp: {message.created_at}")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Author: {message.author}")
                logger.info("🔍 SPECIFIC MESSAGE CHECK - This is the message you mentioned!")
                if message.edited_at:
                    logger.warning("⚠️  MESSAGE WAS EDITED! The content might have been changed after sending.")
                else:
                    logger.info("✅ MESSAGE NOT EDITED - Original content received")

            # Check if message is in target channel
            target_channel_id = self.config_manager.get_target_voice_channel_id()
            logger.debug(f"💬 EVENT: Target channel ID: {target_channel_id}, current channel ID: {message.channel.id}")

            if message.channel.id == target_channel_id:
                logger.debug("💬 EVENT: Message is in target voice channel")
            else:
                logger.debug("💬 EVENT: Message is NOT in target voice channel")

            try:
                await event_handler.handle_message(message)
                logger.debug("💬 EVENT: handle_message completed successfully")
            except Exception as e:
                logger.error(f"💬 EVENT ERROR: handle_message failed: {e}")
                logger.error(f"💬 EVENT ERROR: Exception type: {type(e).__name__}")
                import traceback

                logger.error(f"💬 EVENT ERROR: Traceback: {traceback.format_exc()}")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - ID: {message.id}")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Content: '{message.content}'")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Edited: {message.edited_at}")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Timestamp: {message.created_at}")
                logger.info(f"🔍 SPECIFIC MESSAGE CHECK - Author: {message.author}")
                logger.info("🔍 SPECIFIC MESSAGE CHECK - This is the message you mentioned!")
                if message.edited_at:
                    logger.warning("⚠️  MESSAGE WAS EDITED! The content might have been changed after sending.")
                else:
                    logger.info("✅ MESSAGE NOT EDITED - Original content received")

            # Check if message is in target channel
            target_channel_id = self.config_manager.get_target_voice_channel_id()
            logger.debug(f"💬 EVENT: Target channel ID: {target_channel_id}, current channel ID: {message.channel.id}")

            if message.channel.id == target_channel_id:
                logger.debug("💬 EVENT: Message is in target voice channel")
            else:
                logger.debug("💬 EVENT: Message is NOT in target voice channel")

            try:
                await event_handler.handle_message(message)
                logger.debug("💬 EVENT: handle_message completed successfully")
            except Exception as e:
                logger.error(f"💬 EVENT ERROR: handle_message failed: {e}")
                logger.error(f"💬 EVENT ERROR: Exception type: {type(e).__name__}")
                import traceback

                logger.error(f"💬 EVENT ERROR: Traceback: {traceback.format_exc()}")

        # Mark function as used by Discord.py event system
        _ = on_message
        logger.debug("🔧 SETTING UP EVENTS: on_message event registered")

        logger.debug("🔧 SETTING UP EVENTS: All events setup completed")

        @self.event
        async def on_voice_state_update(member: discord.Member, before: discord.VoiceState, after: discord.VoiceState) -> None:
            """Handle voice state update events - registered by Discord.py automatically."""
            logger.debug(f"🔊 EVENT: on_voice_state_update triggered for {member.name}")
            await event_handler.handle_voice_state_update(member, before, after)

        # Mark function as used by Discord.py event system
        _ = on_voice_state_update
        logger.debug("🔧 SETTING UP EVENTS: on_voice_state_update event registered")

        @self.event
        async def on_disconnect() -> None:
            """Handle bot disconnect events - registered by Discord.py automatically."""
            logger.debug("🔌 EVENT: on_disconnect triggered")
            await event_handler.handle_disconnect()

        # Mark function as used by Discord.py event system
        _ = on_disconnect
        logger.debug("🔧 SETTING UP EVENTS: on_disconnect event registered")

        @self.event
        async def on_error(event: str, *args: Any, **kwargs: Any) -> None:
            """Handle error events - registered by Discord.py automatically."""
            logger.error(f"❌ EVENT: on_error triggered for event '{event}' with args: {args}")
            await event_handler.handle_error(event, *args, **kwargs)

        # Mark function as used by Discord.py event system
        _ = on_error
        logger.debug("🔧 SETTING UP EVENTS: on_error event registered")

    def _setup_commands(self) -> None:
        """Setup commands - all delegated to command handlers."""
        # Command handlers are now initialized, so they should not be None
        if not self.command_handler or not self.slash_handler:
            raise RuntimeError("Command handlers not initialized")

        # Type assertion for mypy since we just checked it's not None
        command_handler = self.command_handler
        _ = self.slash_handler  # Keep reference for type checking

        # Register simple prefix commands that delegate to command handler
        for name in ["status", "skip", "clear", "test", "voices", "voicecheck", "reconnect"]:
            self._add_simple_command(name, command_handler)

        # Note: Slash commands will be registered in setup_hook instead of here
        # to ensure proper Discord.py v2.x initialization timing
        logger.debug("Deferring slash command registration to setup_hook")

    def _add_simple_command(self, name: str, command_handler: CommandHandler) -> None:
        """Add a simple command that delegates to command handler."""

        @self.command(name=name)
        async def cmd(ctx: commands.Context[Any], *, text: str = "") -> None:
            """Handle prefix commands - registered by Discord.py automatically."""
            _ = await command_handler.process_command(ctx.message)

        # Mark function as used by Discord.py command system
        _ = cmd

    async def _process_tts_message_direct(self, message: discord.Message) -> None:
        """Direct TTS message processing bypass - Phase 1 Implementation."""
        try:
            logger.info("🔄 DIRECT TTS: Starting direct message processing")
            logger.info(f"🔄 DIRECT TTS: Processing message: '{message.content}' from {message.author.display_name}")

            # Import the message processor directly to avoid complex event handler chain
            from .message_processor import get_message_processor

            message_processor = get_message_processor(self.config_manager)
            processed_message = await message_processor.process_message(message, self.user.id if self.user else None)

            if processed_message and self.voice_handler:
                logger.info("🔄 DIRECT TTS: Adding processed message to voice queue")
                await self.voice_handler.add_to_queue(processed_message)
                logger.info("✅ DIRECT TTS: Message successfully queued for TTS")
            else:
                logger.warning("🔄 DIRECT TTS: No processed message or voice handler not available")

        except Exception as e:
            logger.error(f"❌ DIRECT TTS ERROR: {e}")
            logger.error(f"❌ DIRECT TTS ERROR: Type: {type(e).__name__}")
            import traceback

            logger.error(f"❌ DIRECT TTS ERROR: Traceback: {traceback.format_exc()}")
            raise  # Re-raise to trigger fallback

    async def shutdown(self) -> None:
        """Graceful shutdown with proper voice channel cleanup."""
        logger.info("Shutting down bot...")

        # First, ensure proper voice channel cleanup before closing Discord connection
        if hasattr(self, "voice_handler") and self.voice_handler:
            try:
                logger.info("🧹 Cleaning up voice connection before shutdown...")
                if self.voice_handler.is_connected():
                    # Get voice channel info before cleanup for logging
                    voice_channel_name = "Unknown"
                    try:
                        if self.voice_handler.voice_client and self.voice_handler.voice_client.channel:
                            voice_channel_name = self.voice_handler.voice_client.channel.name
                    except Exception:
                        pass

                    logger.info(f"🎤 Leaving voice channel: {voice_channel_name}")
                    await self.voice_handler.cleanup_voice_client()
                    logger.info("✅ Voice channel cleanup completed")
                else:
                    logger.debug("No active voice connection to clean up")
            except Exception as e:
                logger.error(f"⚠️ Error during voice cleanup: {e}")
                # Continue with shutdown even if voice cleanup fails

        # Now close the Discord connection
        await self.close()
        logger.info("Bot shutdown complete")


# Factory function for easy bot creation
async def create_bot(config: Any | None = None) -> DiscordVoiceTTSBot:
    """Create a bot instance using factory pattern."""
    # Import here to avoid circular imports
    import importlib

    bot_factory_module = importlib.import_module(".bot_factory", package="discord_voice_bot")
    BotFactory = bot_factory_module.BotFactory

    factory = BotFactory()
    return await factory.create_bot()


# Run bot function
async def run_bot() -> None:
    """Create and run the Discord bot."""
    try:
        from .config_manager import ConfigManagerImpl

        # Create config manager to avoid direct config import
        config_manager = ConfigManagerImpl()
        config_manager.validate()

        bot = await create_bot(None)  # Config is handled by ConfigManagerImpl
        await bot.start(config_manager.get_discord_token())
    except Exception as e:
        logger.error(f"Failed to start bot: {e}")
        raise


# Main execution
if __name__ == "__main__":
    asyncio.run(run_bot())
